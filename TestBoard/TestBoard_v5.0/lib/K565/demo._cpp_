#include <Arduino.h>

//IC Tester
//MCbx 2017
//GNU GPL

#define patsNo 16
const PROGMEM byte patterns[]={0,255,85,170,204,51,153,102, 128, 64, 32, 16,8,4,2,1}; //patterns tested on chip
//85 - 1010, 170 - 0101, 204 - 0011, 51 - 1100, 153 - 1001, 102 - 0110

//chip definitions, sample values not used.
int rows=512;
int cols=512;
unsigned int wait=3000;
long words=262144;
byte addressBits=9;
byte bitsPerWord=1; 

byte menuptr=2;
byte testNo=0;

//prepares program for chosen chip
void prepare(int chipNo)
{
  if (chipNo==1) //4164 OK
  {
    rows=256;
    cols=256;
    words=65536;
    addressBits=8;
  }
}


void setup() {
  prepare(menuptr);

  // //SET PIN MODES
  // FastGPIO::Pin<6>::setOutput(HIGH);
  // FastGPIO::Pin<8>::setOutput(HIGH);
  // FastGPIO::Pin<7>::setOutput(HIGH);
  // FastGPIO::Pin<12>::setOutput(HIGH);
  // FastGPIO::Pin<11>::setOutput(HIGH);
  // FastGPIO::Pin<10>::setOutput(HIGH);
  // FastGPIO::Pin<13>::setOutput(HIGH);
  // FastGPIO::Pin<9>::setOutput(HIGH);
  // FastGPIO::Pin<2>::setOutput(HIGH);
  // FastGPIO::Pin<3>::setOutput(HIGH);
  // FastGPIO::Pin<5>::setOutput(HIGH);
  // FastGPIO::Pin<15>::setOutput(HIGH);
  // FastGPIO::Pin<4>::setOutput(HIGH);
  // FastGPIO::Pin<14>::setInput();
 
    //set refreshing interrupt!
  noInterrupts();           // disable all interrupts
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1 = 0;
  OCR1A = 1024;  //bad value but seems to work. Fails without.
  TCCR1B |= (1 << WGM12); // CTC mode
  TCCR1B |= (1 << CS12); // 256 prescaler
  TIMSK1 |= (1 << OCIE1A); // enable timer compare interrupt
  interrupts(); // enable all interrupts
}

//for 4116, 4164, 41256
void putAddress1(int addr) //this doesn't require NoInterrupts as it's called 
{                       //from inside of noInterrupts function.
    // FastGPIO::Pin<6>::setOutput(bitRead(addr,0));
    // FastGPIO::Pin<8>::setOutput(bitRead(addr,1));
    // FastGPIO::Pin<7>::setOutput(bitRead(addr,2));
    // FastGPIO::Pin<12>::setOutput(bitRead(addr,3));
    // FastGPIO::Pin<11>::setOutput(bitRead(addr,4));
    // FastGPIO::Pin<10>::setOutput(bitRead(addr,5));
    // FastGPIO::Pin<13>::setOutput(bitRead(addr,6));
    // FastGPIO::Pin<9>::setOutput(bitRead(addr,7));
    // FastGPIO::Pin<2>::setOutput(bitRead(addr,8));
}

//Refreshing. this has to be fired regurarly 
ISR(TIMER1_COMPA_vect)        // interrupt service routine 
{  
    for (int i=0;i<rows;i++)
    {
      putAddress1(i);
      // FastGPIO::Pin<5>::setOutput(LOW);
      // FastGPIO::Pin<5>::setOutput(HIGH); 
    }
} 

//write bit to memory, 4116, 4164, 41256
void write_word1(byte data, int row, int col)
{
  // FastGPIO::Pin<3>::setOutput(bitRead(data,0)); //data
  //row addr
  putAddress1(row);
  // FastGPIO::Pin<5>::setOutput(LOW);
  //we
  // FastGPIO::Pin<4>::setOutput(LOW);
  //col addr
  putAddress1(col);
  // FastGPIO::Pin<15>::setOutput(LOW);

  // FastGPIO::Pin<5>::setOutput(HIGH);
  // FastGPIO::Pin<4>::setOutput(HIGH);
  // FastGPIO::Pin<15>::setOutput(HIGH);
}

//read bit from memory, 4116, 4164, 41256
byte read_word1(int row, int col)
{
  byte a=0;
  //row addr
  putAddress1(row);
  //  FastGPIO::Pin<5>::setOutput(LOW);
  // //col addr
  // putAddress1(col);
  // FastGPIO::Pin<15>::setOutput(LOW);
  // bitWrite(a,0,FastGPIO::Pin<14>::isInputHigh());
  
  // FastGPIO::Pin<5>::setOutput(HIGH); 
  // FastGPIO::Pin<15>::setOutput(HIGH);
  return a;
}

//initialize, 4116, 4164, 41256
void initialize_memory1() //shoot 8 RAS cycles before using.
{   //this is important.
  noInterrupts();
  for (byte i=0;i<8;i++)
  {
    // FastGPIO::Pin<5>::setOutput(LOW); 
    // FastGPIO::Pin<5>::setOutput(HIGH); 
  }
  interrupts();
}

//test pattern generator.
short pt1=-1;
byte pattern(byte no,byte bits)
{
  byte k=0;
  for (int i=0;i<bits;i++)
  {
    pt1++;
    if (pt1>7)
      pt1=0;
    bitWrite(k,i,bitRead(no,pt1));
  }
  return k;
}

//error halter
void throw_err(int r, int c, int t, int p)
{
   while(1);
}

void loop() {
  initialize_memory1();
  delay(100);
  for (byte curPatt = 0; curPatt < patsNo; curPatt++) //patterns loop
  {
    pt1=-1;
    noInterrupts();
    //Now by calling rows more frequently, we implicitly refresh memory
    for (int c = 0; c < cols; c++)
    {
      for (int r = 0; r < rows; r++)
      {
        write_word1(pattern(pgm_read_byte_near(patterns+curPatt),bitsPerWord), r,c);
      // Serial.println(pattern(patterns[curPatt],bitsPerWord),BIN); //generator test
      }
    }
    interrupts(); //WAIT: Refreshing interrupt go!

    delay(wait);
    pt1=-1;

    noInterrupts();
    for (int c=0;c<cols;c++)
    {
       for (int r=0;r<rows;r++)
       {
         if (read_word1(r,c) != pattern(pgm_read_byte_near(patterns+curPatt),bitsPerWord))
         {
          interrupts();
//          Serial.println((*read_word)(r,c),BIN);
          throw_err(r,c,testNo,curPatt);
         }
       }
    }
    interrupts();
  }
  testNo++;
}